import { DataParser } from "./data-parser.js";
import CastXML from "../../lib/castxml/castxml.js"
import path from 'path';
import ArrayType from "../../lib/castxml/arraytype.js";
import Struct from "../../lib/castxml/struct.js";
import Field from "../../lib/castxml/field.js";
import assert from "assert";
import * as coreyml from "./core_yaml.js";
import fs from "fs/promises";
import YAML from "yaml";

const knownPerms = [
  'r',
  'w',
  'r/w',
  'rsvd',
  'w1c',
  'w1p',
  'rw', // ???
];


// TODO: Workaround to avoid schema
class YamlHex {
  constructor(number) {
    this._number = number;
  }
}

const yamlHex = {
  identify: v => !!(typeof v === 'object' && v && v instanceof YamlHex),
  stringify: node => '0x' + node.value._number.toString(16)
}

export class RegisterField {
  constructor() {
    this.name = '';
    this.description = '';
    this.bit_size = 0;
    this.bit_offset = 0;
    this.default_value = 0;
    this.permissions = '';
  }
}

export class Register {
  constructor() {
    /** @type {RegisterField[]} */
    this.fields = [];
    this.name = '';
    this.description = '';
    this.byte_size = 0;
    this.byte_offset = 0;
  }
}

export class RegisterHeaderParser {
  /**
   * 
   * @param {DataParser} dataParser 
   */
  constructor (dataParser, fileInfo) {
    /** @type {DataParser} */
    this._dp = dataParser;

    this._fi = fileInfo;
    /** @type {CastXML} */
    this._cxml = null;
    /** @type {Register[]} */
    this.registers = [];
    this.byte_size = 0;
  }



  /**
   * 
   * @param {Register} reg
   * @param {Struct} struct 
   */
  _parseRegFields(reg, struct) {
    let offset = 0;
    for (const member of struct.members) {
      /** @type {Field} */
      const field = member;
      const comment = field.parseComment(this._cxml);
      assert(comment != null);
      let [,bitend,bitstart,perm,defval] = comment.match(/\[([0-9 ]{2})[: ]([0-9 ]{2})\],[ ]+([a-z0-9\/]+),[ ]+(0x[0-9a-f]+|x)/) || [];
      bitend = parseInt(bitend);
      bitstart = parseInt(bitstart);
      if (defval === 'x') {
        defval = '0'
      }
      defval = parseInt(defval, 16);
      assert(!isNaN(defval));
      const regfield = new RegisterField();
      regfield.name = field.name;
      regfield.default_value = defval;
      regfield.bit_size = field.bits;
      regfield.permissions = perm;
      regfield.bit_offset = offset;
      assert(field.bits === (!isNaN(bitend) ? (bitend - bitstart + 1) : 1));
      assert(bitstart === offset);
      assert(knownPerms.includes(perm));
      offset += field.bits;
      reg.fields.push(regfield);
    }
  }

  async parse() {
    const profile = this._dp._profile;
    const fileInfo = this._fi;
    this._cxml = new CastXML();
    await this._cxml.parseFile(path.join(profile.source_dir, this._fi.name));

    const st = this._cxml.structs.find(st => st.name === fileInfo.struct_name);
    assert(st !== undefined);

    let offset = 0;

    for (const member of st.members) {
      if (member.constructor.name !== 'Field') continue;
      /** @type {Field} */
      const field = member;

      if (field.name.startsWith('RESERVED')) {
        /** @type {ArrayType} */
        const type = field.type;
        offset += type.max + 1;
        continue;
      }

      const reg = new Register();
      reg.name = field.name;
      reg.byte_offset = offset;
      /** @type {Struct} */
      let regsStruct = null;
      if (field.type.constructor.name === 'ElaboratedType') {
        if (field.type.type.constructor.name === 'Union' &&
            field.type.type.members.at(-1).name === 'WORD') {
          // It's classic bitfield thingy
          regsStruct = field.type.type.members[0];
        }
      }
      if (regsStruct === null) throw new Error('No regs struct found');

      this._parseRegFields(reg, regsStruct);
      reg.byte_size = regsStruct.size / 8;
      offset += regsStruct.size / 8;

      this.registers.push(reg);
    }
    this.byte_size = offset;
  }

  async saveYaml() {
    const profile = this._dp._profile;
    const fileInfo = this._fi;
    const coreName = fileInfo.name.split('.')[0];
    const outFilePath = path.join(profile.output_dir, `${coreName}.yaml`);
    
    const core = new coreyml.Core();
    core.name = coreName;
    core.byte_size = new YamlHex(this.byte_size);
    core.description = `Generated by bouffalo-data-parser from Bouffalo source code`;

    for (const reg of this.registers) {
      const yreg = new coreyml.Register();
      yreg.name = reg.name;
      yreg.description = reg.description;
      yreg.byte_size = new YamlHex(reg.byte_size);
      yreg.byte_offset = new YamlHex(reg.byte_offset);
      yreg.fieldset = reg.name;

      const yfieldset = new coreyml.Fieldset();
      yfieldset.name = reg.name;

      for (const field of reg.fields) {
        const yfield = new coreyml.Field();
        yfield.name = field.name;
        yfield.description = field.description;
        yfield.bit_size = field.bit_size;
        yfield.bit_offset = field.bit_offset;
        yfield.permissions = reg.permissions;
        yfield.default_value = new YamlHex(field.default_value);
        yfieldset.fields.push(yfield);
      }

      core.fieldsets.push(yfieldset);
      core.registers.push(yreg);
    }
    
    await fs.writeFile(outFilePath, YAML.stringify(core, {
      customTags: [ yamlHex ]
    }));
  }
}